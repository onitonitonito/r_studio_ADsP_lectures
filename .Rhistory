### ----------------------------------------------------------------
#kings <- read.table("http://robjhyndman.com/tsdldata/misc/kings.dat", header=TRUE, sep=",",
#                   stringsAsFactors=FALSE, na.strings=c('NIL'),
#                   comment.char="#", encoding="UTF-8")
#kings <- scan("http://robjhyndman.com/tsdldata/misc/kings.dat", what = real, Age)
#write.table(data, file="data/data.csv", append=FALSE, quote=FALSE, sep=",", row.names=FALSE)
### ----------------------------------------------------------------
kingstimeseries <- ts(kings)            #ts함수를 활용하여 데이터를 시계열데이터로 변환
kingstimeseries
"____ (SET) TIME SERIES DATA ___
Time Series:   Start = 1 / End = 42 / Frequency = 1
"
plot.ts(kingstimeseries)                #plot.ts 함수를 활용하여 시계열데이터를 도식화
#SMA 함수를 이용해 간단한 시계열트랜드를 보여주는 분해시계열 이동평균그래프 그리기
kingstimeseriesSMA3 <- SMA(kingstimeseries,n=3)
plot.ts(kingstimeseriesSMA3)
kingstimeseriesSMA8<-SMA(kingstimeseries,n=8)
plot.ts(kingstimeseriesSMA8)
kingstimeseriesSMA12<-SMA(kingstimeseries,n=12)
plot.ts(kingstimeseriesSMA12)
par(mfrow=c(2,2))                        # 하나의 그래프 화면에 함꼐 표현하기
plot.ts(kingstimeseries)
plot.ts(kingstimeseriesSMA3)
plot.ts(kingstimeseriesSMA8)
plot.ts(kingstimeseriesSMA12)
# 차분하여 정상성 확인하기 (difference) - diff 함수를 활용하여 데이터 차분하기
kingstimeseriesdiff1 <- diff(kingstimeseries, differences = 1)
kingstimeseriesdiff2 <- diff(kingstimeseries, differences = 2)
kingstimeseriesdiff3 <- diff(kingstimeseries, differences = 3)
kingstimeseriesdiff1
kingstimeseriesdiff2
kingstimeseriesdiff3
par(mfrow=c(2,2))
plot.ts(kingstimeseriesdiff1)   #1차 차분한 결과, 평균과 분산이 시간에 의존하지 않음
plot.ts(kingstimeseriesdiff2)
plot.ts(kingstimeseriesdiff3)
# 차분을 높일수록, 평균은높아지고, 분산은 커진다.
mean(kingstimeseriesdiff1)
sd(kingstimeseriesdiff1)
mean(kingstimeseriesdiff2)
sd(kingstimeseriesdiff2)
mean(kingstimeseriesdiff3)
sd(kingstimeseriesdiff3)
# ARIMA모델 결졍하기 ARIMA(p, 1, q) - AR(p),차분홧수, MA(q)
# acf()함수와 pacf()를 사용하여 결정한다.
par(mfrow=c(2,2))
acf(kingstimeseriesdiff1, lag.max=20)          #1?? ?????? ?????ͷ? (ACF) Ȯ??
acf(kingstimeseriesdiff1, lag.max=20, plot=FALSE)
#--- lag = 0 지점은 읽지 않음
#--- lag = 1 인 지점만 점선 구간밖에 있음
#--- lag = 2 인 지점부터 모두 점선 구간안에 있음 lag가 2에서 절단점을 가짐 -> MA(1)모형
pacf(kingstimeseriesdiff1, lag.max=20)         #1?? ?????? ?????ͷ? (PACF) Ȯ??
pacf(kingstimeseriesdiff1, lag.max=20, plot=FALSE)
#--- lag = 0 지점은 자료 없음
#--- lag = 1, 2, 3 지점만 점선 구간밖에 있음
#--- lag = 4 인 지점부터 모두 점선 구간안에 있음 lag가 4에서 절단점을 가짐 -> AR(3) 紐⑦삎
# forecast package 에 내장된 auto.arima 함수를 이용한 모형 찾기
auto.arima(kings)
#--- ARIMA(0, 1, 1) 을 가장 적절한 모형으로 선택
#  ARIMA 모형을 통해 미래 예측하기
# ARIMA모형으로 데이터 보정하기(fitting)
kingstimeseriesARIMA<- arima(kingstimeseries, order=c(0, 1, 1))
kingstimeseriesARIMA
# forecast.Arima 함수를 통해 미래 예측하기
kingstimeseriesforecasts<-forecast(kingstimeseriesARIMA)
kingstimeseriesforecasts
# 5명을 예측하고자 한다면 h=5로 지정가능
kingstimeseriesforecasts<-forecast(kingstimeseriesARIMA,h=5)
kingstimeseriesforecasts
# 미래 예측에 대한 도표 그리기
par(mfrow=c(1,1))
plot(kingstimeseriesforecasts)
getwd()
###### 작업 공간 할당하기 ###
setwd("~/GitHub/r_studio_ADsP_lectures/book")
getwd()
data(Animals)                  #데이터 확인 가능
data(Animals)                  #데이터 확인 가능
Animals
data(Animals)                  #데이터 확인 가능
summary(Animals)
.libPaths()                    #현재 패키지들이 저장되는 장소
installed.packages()           #현재 저장되어 있는 패키지들이 저장되는 장소 및 기능설명
nrow(installed.packages())
x <- c("a", "b", "c", "d")
x <- c("a", "b", "c", "d")
x
a <<- 3     # (전역변수) 화살표 2개를 사용한다.
a
b = 4       # 함수() 안에 들어가는 연산자는 '이퀄'을 사용한다.
b
5 -> c      # 방향성에 관계없이도 사용 가능하다.
c
ls()
ls.str()            # 변수 세팅에 대하여 상세하게 보여준다
ls.str(Animals)     # 특정 데이터만 별도로 보고 싶을 경우
ls()
.kkk<-12
.kkk
objects()                  # 변수를 조회하는 함수
mode(g)
g <- c(d,e,c(7,8,9))
d <- c(1, 2, 3)
e <- c(4, 5, 6)
f <- c("a", "b", "c")
g <- c(d,e,c(7,8,9))
g
h <- c(d,f)      # 숫자와 문자를 결함하면 모두 '문자'가 됨  ... "1" "2" "3" "a" "b" "c"
h
rm(d,e,f,g,h)
rm(x,y)
mode(g)
mode(h)
c(0, 1, 1, 2, 3, 5, 8, 13)     # 1차원 백터 = Cobine() 함수를 사용해서 결함시킴.
c(1*pi, 2*pi, 3*pi, 4*pi)
c("I", "love", "you.")
c(TRUE, TRUE, FALSE, FALSE)
a <- rnorm(20)   # 노말 랜덤숫자 20개를 추출해준다 (0~1)
b <- hist(a)
View(b)
View(b)
mode(a)
mode(a)
class(a)
mode(a)
class(a)
## 단하나의 NA 값이 포함되어도 결과는 NA로 나오므로 아래와 같이 활용
c        # 결측값(NA)를 포함하고 있는 자료
mean(c)  # NA가 나옴  ... 10개의 데이터중 1개의 NA가 있는 경우
sd(c)    # NA 가 나옴...  마찬가지로 표준편차도 안나옴 (NA)
a <- c(0,1,1,2,3,5,8,13)
b <- log(a+1)
c <- c(0,1,1,2,3,5,8,13,NA)
## 단하나의 NA 값이 포함되어도 결과는 NA로 나오므로 아래와 같이 활용
c        # 결측값(NA)를 포함하고 있는 자료
mean(c)  # NA가 나옴  ... 10개의 데이터중 1개의 NA가 있는 경우
sd(c)    # NA 가 나옴...  마찬가지로 표준편차도 안나옴 (NA)
mean(c, na.rm=TRUE)  # 평균을 낼때, NA값을 지우고 계산
sd(c, na.rm=TRUE)    # 표준편차를 낼때 NA값을 지우고 계산한다고 써줘야 함
height <- c(187, 178, 176, 169, 181, 172)
weight <- c(82, 72, 70, 65, 74, NA)
df_1<-data.frame(height, weight)
View(df_1)
View(df_1)
df<-data.frame(
height=c(187,178,176,169,181,172),
weight=c(82,72,70,65,74,68)
)
df
mean(df)      # NA를 반환한다 - 인자가 수치형/논리형이 아니므로 NA를 반환한다.
mean(df$height)
sd(df$height)
1:10
seq(from=1, to=10, by=2)
rep(1,times=5)
1:10
0:9
5:10
9:0
z == z2             # 백터와 스칼라비교 : 1:1 로 반복비교 F T F
z <- c(3, pi, 4)    # 1차원 '벡터'
z1 <- c(pi,pi,4)    # 1차원 '벡터'
z == z1             # 같은 위치의 원소끼리 비교 = F T T
z == z2             # 백터와 스칼라비교 : 1:1 로 반복비교 F T F
z2 = pi             # 0차원 '스칼라'
z == z2             # 백터와 스칼라비교 : 1:1 로 반복비교 F T F
z == z1             # 같은 위치의 원소끼리 비교 = F T T
z == z2             # 백터와 스칼라비교 : 1:1 로 반복비교 = F T F
z + z2    # 자기복제로 갯수를 맞춘후 연산을 한다.
z3 = c(1, 2, 3, 4, 5)
z4 = c(1, 2)
z3 + z4     # z4 = c(1,2,1,2,1) --> (2 4 4 6 6)
any(z == z1)  # 벡터의 값들 중 하나라도 같은가?
z == z1
any(z == z1)  # 벡터의 값들 중 하나라도 같은가?
all(z == z1)  # 벡터의 값들이 모두 같은가?   all(z==0) 모든 값들이 0인가?는 많이 활용된다.
a <- c(0, 1, 1, 2, 3, 5, 8, 13, NA)        # NA값 1개 포함.
a
a[1]
a[2]
a[3]
a[1:3]
a[4:7]
a[4:7]  # 4 ~ 7
a[c(1,3,5,7)]   # 1,3,5,7번째 = 0 1 3 8
a[1,3,5,7]      # 에러발생 (컴바인 함수()를 사용해야 함) : incorrect number of dimensions
a
a <- a[-NA]
a
a
a
a <- c(0, 1, 1, 2, 3, 5, 8, 13, NA)        # NA값 1개 포함.
a
b <- a[-NA]
b
a
b <- c(a[-NA])
b
a[NA]
a[:]
a[1:]
c(a[1:])
a <-c (0,1,1,2,3,5,8,13)   # NA 값을 처리해 줘야 함 (에러a <-c (0,1,1,2,3,5,8,13,NA)
a
median(a)
a > median(a)
a [a>median(a)]
# 상하위 5% 안에 있는 모든 원소를 선택
a[a<quantile(a,0.05)|a>quantile(a,0.95)]
# 평균에서 + - 표준편차를 넘는 모든 원소 선택
a-mean(a)>2*sd(a)
# 평균에서 + - 표준편차를 넘는 모든 원소 선택
a[a-mean(a) > 2*sd(a)]
a[abs(a-mean(a)) > 2*sd(a)]
a <- c(0, 1, 1, 2, 3, 5, 8, 13, NA)        # NA값 1개 포함.
a
b <- c(a[a != NA])
b
a[a != NA]
a != NA
a != "NA"
a == "NA"
a != "NA"
b <- c(a[a != "NA"])
b
a != "NA"
b <- c(a[a != NA])
b
a != NA
a == NA
a == "NA"
b <- c(a[a == "NA"])
b
b <- c(a[a != "NA"])
b
b <- complete.cases(a)
b
b <- a[complete.cases(a)]
b
a == "NA"
complete.cases(a)
a                  # 0  1  1  2  3  5  8 13 NA
a == "NA"          # FFFFFF NA  ... 조건문으로 쓸수 없다
complete.cases(a)  # TTTTTT F   ... 조건문으로 가능.
b <- a[complete.cases(a)]  # NA를 제외한 맴버를 골라서 'b'에 할당한다.
b
# NA나 NULL이 아닌 모든 원소를 선택
a <- c(1,2,NA,3,4)
a
mean(a)
b<-c(1,2,NULL,3,4)
b
mean(b)
b<-c(1,2,NULL,3,4)
b
mean(b)               # NULL 은 인식하지 않는다.
a
a[!is.na(a) & !is.null(a)]
is.na(a)
!is.na(a)
!is.null(a)
!is.null(a)
is.null(a)        #
!is.na(a)          # T T F T T
!is.null(a)        # All TRUE 일때는 한개의 TRUE 만 반환한다 = ㅆ껴ㄸ
!is.null(a)        # All TRUE 일때는 한개의 TRUE 만 반환한다 = TRUE
a
a <-a[!is.na(a)|!is.null(a)]   # NA 값을 처리해 줘야 함 (에러a <-c (0,1,1,2,3,5,8,13,NA)
a
a <- a[!is.na(a)|!is.null(a)]   # NA 값을 처리해 줘야 함 (에러a <-c (0,1,1,2,3,5,8,13,NA)
a
a <- a[!is.na(a) & !is.null(a)]   # NA 값을 처리해 줘야 함 (에러a <-c (0,1,1,2,3,5,8,13,NA)
a
# NA나 NULL이 아닌 모든 원소를 선택
a <- c(1,2,NA,3,4)
a
a[!is.na(a) & !is.null(a)]
a <- a[!is.na(a) & !is.null(a)]   # NA 값을 처리해 줘야 함 (에러a <-c (0,1,1,2,3,5,8,13,NA)
a
names(a) <- c("1st","2nd","3th","4th","5th","6th","7th","8th")
# --------------------------------------------------------------------------
a <-c (0,1,1,2,3,5,8,13)   # NA 값을 처리해 줘야 함 (에러a <-c (0,1,1,2,3,5,8,13,NA)
names(a) <- c("1st","2nd","3th","4th","5th","6th","7th","8th")
a
a["2nd"]
a["4th"]
v1 <- c(10,11,12,13,14)
v2 <- c(1,2,3,4,5)
v1 <- c(10, 11, 12, 13, 14)
v2 <- c(1, 2, 3, 4, 5)
v1 + v2
v1 - v2
v1 * v2
v1 / v2
v1 ^ v2
v1 + 2
v1 - 2
v1 * 2
v1 / 2
v1 ^ 2
mean(v1)
height <- c(187, 178, 176, 169, 181, 172)
weight <- c(82, 72, 70, 65, 74, 82)
BMI(height, weight)
BMI <- function(x,y)  (x-100)/y
BMI(height, weight)
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
m1 <- lm(y ~ x1 , data = data1)
abline(m1$coefficients)
hist(x1)
plot( y ~ x2)
m2 <- lm(y ~ x2 , data = data1)
abline(m2$coefficients)
hist(x2)
par(mfrow=c(1,1))
return(c(x1, x2))
}
y <- SalePrice$SalePrice         # 집값
# 집이 지어진 년도 / 리모델링을 한 집의 준공년도
x1 <- SalePrice$YearBuilt
x2 <- SalePrice$YearRemodAdd
x3 <- SalePrice$GrLivArea
x4 <- SalePrice$LotArea
show_phist(y, (x1), (x2), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
rm(list=ls())
setwd("~/GitHub/r_studio_ADsP_lectures")
SalePrice <- read.csv("./_static/Boston_sale_price_train.csv")
# fix(SalePrice)
head(SalePrice)
colnames(SalePrice)
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
m1 <- lm(y ~ x1 , data = data1)
abline(m1$coefficients)
hist(x1)
plot( y ~ x2)
m2 <- lm(y ~ x2 , data = data1)
abline(m2$coefficients)
hist(x2)
par(mfrow=c(1,1))
return(c(x1, x2))
}
y <- SalePrice$SalePrice         # 집값
# 집이 지어진 년도 / 리모델링을 한 집의 준공년도
x1 <- SalePrice$YearBuilt
x2 <- SalePrice$YearRemodAdd
x3 <- SalePrice$GrLivArea
x4 <- SalePrice$LotArea
show_phist(y, (x1), (x2), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
aa <- show_phist(y, (x1), (x2), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
show_phist(y, (x3), (x4), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
show_phist(y, log(x3), log(x4), SalePrice)
aa <- show_phist(y, (x1), (x2), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
bb <- show_phist(y, (x3), (x4), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
bb1 <- show_phist(y, log(x3), log(x4), SalePrice)
aa
plot(aa)
par(mfrow=c(1,1))
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
m1 <- lm(y ~ x1 , data = data1)
abline(m1$coefficients)
hist(x1)
plot( y ~ x2)
m2 <- lm(y ~ x2 , data = data1)
abline(m2$coefficients)
hist(x2)
par(mfrow=c(1,1))
}
# 2개의 백터값으로 반환했기 때문에 받아주는 변수가 있어야 한다.
aa <- show_phist(y, (x1), (x2), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
bb <- show_phist(y, (x3), (x4), SalePrice)     # 2개변수의 플롯(plot) + 분포(hist)
bb1 <- show_phist(y, log(x3), log(x4), SalePrice)
plot(aa)
aa
getwd()
boston <-read.csv(("./_static/bostonc_new.csv"))
View(boston)
View(boston)
plot(poscton)
plot(boscton)
plot(boston)
plot(boston)
getwd()
# -------------------------------------------------------------
# bostonc <- read.table(
#     "http://lib.stat.cmu.edu/datasets/boston_corrected.txt",
#     header=TRUE, sep=",", stringsAsFactors=FALSE,
#     na.strings=c('NIL'), comment.char="#", encoding="UTF-8")
# -------------------------------------------------------------
getwd()
boston <-read.csv("./_static/bostonc_new.csv", header = TRUE, sep = "," )
head(boston); tail(boston)
summary(boston)
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
m1 <- lm(y ~ x1 , data = data1)
abline(m1$coefficients)
hist(x1)
plot( y ~ x2)
m2 <- lm(y ~ x2 , data = data1)
abline(m2$coefficients)
hist(x2)
par(mfrow=c(1,1))
}
show_phist(,bos)
show_phist(y, x1, x2,boston)
y <- boston$LSTAT
x1 <- boston$CHAS
x2 <- boston$CRIM
show_phist(y, x1, x2, boston)
show_phist(y, x1, log(x2), boston)
y <- boston$INDUS
x1 <- boston$CHAS
x2 <- boston$CRIM
show_phist(y, x1, log(x2), boston)
show_phist(y, log(x1), log(x2), boston)
y <- boston$INDUS
x1 <- boston$CHAS
x2 <- boston$CRIM
show_phist(y, log(x1), log(x2), boston)
show_phist(y, (x1), log(x2), boston)
y <- boston$INDUS
x1 <- boston$INDUS
x2 <- boston$CRIM
show_phist(y, (x1), log(x2), boston)
show_phist(y, log(x1), log(x2), boston)
show_phist(y, log(x1), (x2), boston)
show_phist(y, (x1), log(x2), boston)
plot(y, log(x1))
plot(y, log(x1))
1))
hist(log(x1))
plot(y, log(x1))
hist(log(x1))
par(mfrow=c(2,2))
plot(y, log(x1))
hist(log(x1))
y <- boston$MEDV
x1 <- boston$INDUS
x2 <- boston$CRIM
show_phist(y, (x1), log(x2), boston)
par(mfrow=c(2,2))
plot(y, log(x1))
hist(log(x1))
show_phist(y, (x1), log(x2), boston)
show_phist(y, log(x1), log(x2), boston)
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
m1 <- lm(y ~ x1 , data = data1)
#  abline(m1$coefficients)
hist(x1)
plot( y ~ x2)
m2 <- lm(y ~ x2 , data = data1)
#  abline(m2$coefficients)
hist(x2)
par(mfrow=c(1,1))
}
show_phist(y, log(x1), log(x2), boston)
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
#  m1 <- lm(y ~ x1 , data = data1)
#  abline(m1$coefficients)
hist(x1)
plot( y ~ x2)
#  m2 <- lm(y ~ x2 , data = data1)
#  abline(m2$coefficients)
hist(x2)
par(mfrow=c(1,1))
}
show_phist(y, log(x1), log(x2), boston)
show_phist(y, (x1), (x2), boston)
y <- boston$PTRATIO
show_phist(y, (x1), (x2), boston)
plot(boston)
y <- boston$ZN
show_phist(y, (x1), (x2), boston)
# ________함수정의 _______________
show_phist <- function(y, x1, x2, data1)  {
par(mfrow=c(2,2))
plot( y ~ x1)
hist(x1)
#  m1 <- lm(y ~ x1 , data = data1)
#  abline(m1$coefficients)
plot( y ~ x2)
hist(x2)
#  m2 <- lm(y ~ x2 , data = data1)
#  abline(m2$coefficients)
par(mfrow=c(1,1))
}
show_phist(y, (x1), (x2), boston)
y <- boston$MED\
y <- boston$MEDV
show_phist(y, (x1), (x2), boston)
show_phist(y, log(x1), log(x2), boston)
show_phist(log(y), log(x1), log(x2), boston)
show_phist(log(y), (x1), (x2), boston)
show_phist((y), log(x1), log(x2), boston)
show_phist(log(y), log(x1), log(x2), boston)
